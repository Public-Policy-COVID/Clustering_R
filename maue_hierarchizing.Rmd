---
output:
  word_document: default
  html_document: default
  pdf_document: default
---


```{r}
link='https://github.com/Public-Policy-COVID/students_merge/raw/main/Merged_data.csv'

myfile=url(link)

covid=read.csv(file=myfile)

row.names(covid)=NULL

str(covid,width = 50,strict.width='cut')

##We need to prepare the variables for clustering

##First, we want to include the variable for COVID deaths in the cluster analysis, but it is currently a string variable. We will need to change to numberic

as.numeric('Deaths_COVID')

##Now, we will choose the variables to cluster around COVID deaths. We will include total population, mask score, the number of hospital beds, the total percent of the population that is white, and the total percent of the population that is black. Although we only have total deaths and not deaths per 100K, clustering around total population should help control for variation due to population. 

dfClus=covid[c('Number_of_beds','mask_score','Deaths_COVID','Deaths_total','Number_of_hospitals', 'black_total_pct','white_total_pct')]

summary(dfClus)

dfClus=scale(dfClus)

summary(dfClus)

row.names(dfClus)=covid$Location
head(dfClus)

set.seed(999)

library(cluster)
dfClus_D=cluster::daisy(x=dfClus)

library(factoextra)


##Setting the number of clusters
NumCluster=4

res.agnes= hcut(dfClus_D, 
                k = NumCluster,isdiss=T,
                hc_func='agnes',
                hc_method = "ward.D2")

##Cluster

covid$agn=as.factor(res.agnes$cluster)

##Let's check the first cluster, just for reference

covid[covid$agn==1,'Location']


##Let's check the results through a table

table(covid$agn)

##The results indicate that Cluster 4 has only one observation. Let's check which county it is.

covid[covid$agn==4,'Location']

##Los Angeles County appears to be the sole observation.

##Let's check King County's cluster

covid[covid$Location=="King_WA",'agn']

##VISUALIZING RESULTS


##A dendrogram of the cluster results

fviz_dend(res.agnes,k=NumCluster, cex = 0.7, horiz = T)

library(factoextra)


##Let's visualize our cluster results with a silhouette plot

fviz_silhouette(res.agnes)

##It appears that clusters 1,2, and 3 each have negative silhouettes, which means these are poorly clustered

#Saving individual silhouettes

agnEval=data.frame(res.agnes$silinfo$widths)
head(agnEval)


##Let's check the observations with negative silhouettes

agnEval[agnEval$sil_width<0,]

##In total, there are nine observations that are poorly clustered: One in cluster 1, Seven in Cluster 2, and One in Cluster 3


## Hierachizing Divisive method


##Indicating required clusters

library(factoextra)

res.diana= hcut(dfClus_D, k = NumCluster,
                 hc_func='diana',
                 hc_method = "ward.D")

##Clustering 

covid$dia=as.factor(res.diana$cluster)

##Querying the data frame
covid[covid$dia==1, 'Location']

## We will also check the results by each cluster:
table(covid$dia)

#The results indicate that Cluster 2 has the majority of observations. Let's check that one

covid[covid$dia==2, 'Location']


##Let's check King County:

covid[covid$Location=="King_WA" , 'dia']


##Now, to evaluate results, we will produce a cluster dendrogram

fviz_dend(res.diana,k=NumCluster, cex = 0.7, horiz = T)

##Report average silhouettes

library(factoextra)
fviz_silhouette(res.diana)

#Cluster 2 has a negative silhouette, meaning it is poorly clustered. 

##Next we will save silhouettes

diaEval=data.frame(res.diana$silinfo$widths)
head(diaEval)

##Let's check the poorly clustered silhouette in Cluster 2

diaEval[diaEval$sil_width<0,]

##It looks like Multnomah County is the poorly clustered result



##COMPARING AGGLOMERATING AND DIVISIVE CLUSTERS

projectedData = cmdscale(dfClus_D, k=2)
#
# save coordinates to original data frame:
covid$dim1 = projectedData[,1]
covid$dim2 = projectedData[,2]

##Map the clusters

base= ggplot(data=covid,
             aes(x=dim1, y=dim2,
                 label=Location)) 
base + geom_text(size=2)

##Plot the Agglomerating Results

agnPlot=base + labs(title = "AGNES") + geom_point(size=2,
                                              aes(color=agn),
                                              show.legend = F) 


##Plot the Divisive Results

diaPlot=base + labs(title = "DIANA") + geom_point(size=2,
                                              aes(color=dia),
                                              show.legend = F) 

##Let's look at the visual results

library(ggpubr)
ggarrange(agnPlot, diaPlot,ncol = 3)

##From the visual plots, the results for both hierarchical clustering methods appear to be pretty consistent

##We can label the two hierarchical clustering plots

library(ggrepel)
agnPlot + geom_text_repel(size=3,aes(label=Location))
diaPlot + geom_text_repel(size=3,aes(label=Location))



#It looks like there are too many overlaps for the large majority of names to appear. Instead, we will need to try and label anomalies from the agn and dia plots


LABEL=ifelse(diaEval$sil_width<0, covid$Location,"")

diaPlot + geom_text_repel(aes(label=LABEL))

LABEL=ifelse(agnEval$sil_width<0, covid$Location,"")

agnPlot + geom_text_repel(aes(label=LABEL))


```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
